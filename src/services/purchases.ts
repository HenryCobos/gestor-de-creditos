import Constants from 'expo-constants';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Variables para RevenueCat
let Purchases: any = null;
let isExpoGo: boolean = false;
let isInitialized: boolean = false;

async function ensurePurchasesLoaded(): Promise<any> {
  if (isInitialized) {
    return isExpoGo ? null : Purchases;
  }

  // Inicializar RevenueCat de forma segura
  try {
    const module = require('react-native-purchases');
    Purchases = module.default || module;
    isExpoGo = (Constants as any)?.appOwnership === 'expo';
    isInitialized = true;
    console.log('‚úÖ RevenueCat cargado correctamente');
  } catch (error) {
    console.log('‚ÑπÔ∏è RevenueCat no disponible, usando modo simulaci√≥n');
    isExpoGo = true;
    isInitialized = true;
  }

  return isExpoGo ? null : Purchases;
}

export interface PremiumState {
  isPremium: boolean;
  customerInfo: any | null;
  offerings: any | null;
  loading: boolean;
  error: string | null;
}

export class PurchasesService {
  static initialized = false;
  static usingSimulatedOfferings = false;

  static async initialize(apiKey: string): Promise<void> {
    if (this.initialized) return;
    
    const mod = await ensurePurchasesLoaded();
    if (!mod) {
      console.log('‚ÑπÔ∏è RevenueCat no disponible, usando modo simulaci√≥n');
      this.initialized = true;
      return;
    }
    
    try {
      // Configuraci√≥n para versi√≥n 4.x - usar setup en lugar de configure
      await mod.setup(apiKey);
      this.initialized = true;
      console.log('‚úÖ RevenueCat inicializado correctamente');
    } catch (error: any) {
      console.log('‚ö†Ô∏è Error inicializando RevenueCat (usando modo simulaci√≥n):', error.message);
      // En caso de error, marcar como inicializado para evitar loops
      this.initialized = true;
    }
  }

  static async getOfferings(): Promise<any | null> {
    const mod = await ensurePurchasesLoaded();
    const isExpoGo = (Constants as any)?.appOwnership === 'expo';
    const isLocalDevelopment = __DEV__ && !isExpoGo;
    
    if (!mod) {
      // Fallback solo para Expo Go
      console.log('üì¶ RevenueCat no disponible - modo Expo Go');
      if (isLocalDevelopment || isExpoGo) {
        this.usingSimulatedOfferings = true;
        return this.getSimulatedOfferings();
      }
      return { availablePackages: [] };
    }
    
    try {
      const offerings = await mod.getOfferings();
      if (offerings && offerings.current && offerings.current.availablePackages && offerings.current.availablePackages.length > 0) {
        console.log('‚úÖ PRODUCTOS REALES encontrados en RevenueCat');
        console.log('üì¶ Cantidad:', offerings.current.availablePackages.length);
        this.usingSimulatedOfferings = false;
        return offerings.current;
      } else {
        console.warn('‚ö†Ô∏è No hay productos disponibles en RevenueCat');
        
        // Solo simular en desarrollo local
        if (isLocalDevelopment) {
          console.log('üì± Desarrollo local: usando simulaci√≥n');
          this.usingSimulatedOfferings = true;
          return this.getSimulatedOfferings();
        } else {
          // En producci√≥n: devolver vac√≠o y mostrar error al usuario
          console.error('‚ùå PRODUCCI√ìN/TESTFLIGHT: No hay productos configurados');
          this.usingSimulatedOfferings = false;
          return { availablePackages: [] };
        }
      }
    } catch (error: any) {
      console.error('‚ùå Error obteniendo ofertas:', error.message);
      
      // Solo simular en desarrollo local
      if (isLocalDevelopment) {
        console.log('üì± Desarrollo: simulando por error');
        this.usingSimulatedOfferings = true;
        return this.getSimulatedOfferings();
      } else {
        console.error('‚ùå PRODUCCI√ìN: Error - usuarios ver√°n mensaje');
        this.usingSimulatedOfferings = false;
        return { availablePackages: [] };
      }
    }
  }

  private static getSimulatedOfferings() {
    return {
      availablePackages: [
        {
          identifier: 'gdc_pro_monthly',
          packageType: 'MONTHLY',
          product: {
            priceString: '$9.99',
            price: 9.99,
            title: 'Mensual',
            productIdentifier: 'gdc_pro_monthly'
          }
        },
        {
          identifier: 'gdc_pro_yearly',
          packageType: 'ANNUAL',
          product: {
            priceString: '$59.99',
            price: 59.99,
            title: 'Anual',
            productIdentifier: 'gdc_pro_yearly'
          }
        }
      ]
    };
  }

  static async getCustomerInfo(): Promise<any> {
    const mod = await ensurePurchasesLoaded();
    
    // Solo usar modo simulaci√≥n en Expo Go
    const isExpoGo = (Constants as any)?.appOwnership === 'expo';
    
    if (!mod || isExpoGo) {
      // Fallback para Expo Go o desarrollo - verificar si hay compra simulada
      console.log('üë§ Obteniendo informaci√≥n del cliente simulada');
      const hasSimulatedPurchase = await this.getSimulatedPurchaseStatus();
      console.log('üîç Estado de compra simulada:', hasSimulatedPurchase);
      return {
        entitlements: {
          active: hasSimulatedPurchase ? { pro: { isActive: true } } : {},
          all: {}
        },
        activeSubscriptions: hasSimulatedPurchase ? ['gdc_pro_monthly'] : [],
        nonSubscriptionTransactions: []
      };
    }
    
    try {
      // RevenueCat 4.x usa getPurchaserInfo en lugar de getCustomerInfo
      return await mod.getPurchaserInfo();
    } catch (error) {
      console.error('‚ùå Error obteniendo informaci√≥n del cliente:', error);
      throw error;
    }
  }

  // M√©todo para manejar compras simuladas
  private static async getSimulatedPurchaseStatus(): Promise<boolean> {
    try {
      const simulatedPurchase = await AsyncStorage.getItem('@creditos_app:simulated_purchase');
      return simulatedPurchase === 'true';
    } catch {
      return false;
    }
  }

  private static async setSimulatedPurchaseStatus(purchased: boolean): Promise<void> {
    try {
      await AsyncStorage.setItem('@creditos_app:simulated_purchase', purchased.toString());
    } catch (error) {
      console.error('Error guardando estado de compra simulada:', error);
    }
  }

  static async purchasePackage(selected: any): Promise<any> {
    console.log('üõí purchasePackage llamado con:', selected);
    const mod = await ensurePurchasesLoaded();
    
    // Solo simular en DESARROLLO LOCAL (no en TestFlight/Producci√≥n)
    const isExpoGo = (Constants as any)?.appOwnership === 'expo';
    const isLocalDevelopment = __DEV__ && !isExpoGo;
    
    console.log('üõí Estado del entorno:', { 
      isExpoGo, 
      isDevelopment: __DEV__, 
      isLocalDevelopment,
      hasMod: !!mod, 
      usingSimulatedOfferings: this.usingSimulatedOfferings 
    });
    
    // SOLO simular en desarrollo local, NUNCA en TestFlight/producci√≥n
    if (!mod || isExpoGo || (isLocalDevelopment && this.usingSimulatedOfferings)) {
      // Simular compra cuando RevenueCat no est√° disponible o en desarrollo
      console.log('üé≠ MODO SIMULACI√ìN ACTIVO - Los productos reales no est√°n disponibles');
      console.log('üì± Esto es normal en desarrollo. En producci√≥n (TestFlight/App Store), las compras funcionar√°n correctamente.');
      console.log('üõí Simulando compra de:', {
        identifier: selected?.identifier || 'gdc_pro_monthly',
        packageType: selected?.packageType || 'MONTHLY',
        price: selected?.product?.priceString || '$9.99'
      });

      // Simular delay de compra
      await new Promise(resolve => setTimeout(resolve, 1500));

      await this.setSimulatedPurchaseStatus(true);

      console.log('‚úÖ Compra simulada completada - Usuario es ahora Premium (simulado)');

      return {
        entitlements: {
          active: {
            pro: {
              isActive: true,
              willRenew: true,
              periodType: selected?.packageType || 'MONTHLY',
              expirationDate: new Date(Date.now() + ((selected?.packageType || 'MONTHLY') === 'MONTHLY' ? 30 : 365) * 24 * 60 * 60 * 1000).toISOString()
            }
          },
          all: {}
        },
        activeSubscriptions: [selected?.identifier || 'gdc_pro_monthly'],
        nonSubscriptionTransactions: []
      };
    }

    // Validar que el paquete sea v√°lido antes de intentar comprar
    if (!selected || !selected.product || !selected.product.productIdentifier) {
      console.error('‚ùå Paquete inv√°lido - no se puede comprar');
      throw new Error('Los productos no est√°n disponibles. Verifica tu conexi√≥n e intenta de nuevo.');
    }

    console.log('üõí Iniciando compra REAL con RevenueCat:', {
      identifier: selected.identifier,
      packageType: selected.packageType,
      price: selected.product?.priceString,
      productId: selected.product.productIdentifier
    });

    try {
      const purchaseResult = await mod.purchasePackage(selected);
      const customerInfo = purchaseResult.customerInfo;
      
      console.log('‚úÖ Compra exitosa:', {
        entitlements: Object.keys(customerInfo.entitlements.active),
        isPro: customerInfo.entitlements.active["pro"] != null,
        productIdentifier: purchaseResult.productIdentifier
      });
      
      return customerInfo;
    } catch (error: any) {
      console.error('‚ùå Error en compra:', {
        code: error.code,
        message: error.message,
        userCancelled: error.userCancelled
      });
      
      // Si el usuario cancela, no mostrar error
      if (error.userCancelled) {
        console.log('‚ÑπÔ∏è Usuario cancel√≥ la compra');
        throw new Error('Compra cancelada');
      }
      
      // Manejar errores espec√≠ficos de validaci√≥n de recibos
      // RevenueCat maneja autom√°ticamente el cambio entre producci√≥n y sandbox
      if (error.message && (
        error.message.includes('Sandbox receipt used in production') ||
        error.message.includes('receipt')
      )) {
        console.log('‚ö†Ô∏è Error de validaci√≥n de recibo - RevenueCat lo manejar√° autom√°ticamente');
        // No lanzar error espec√≠fico, dejar que RevenueCat maneje la validaci√≥n
      }
      
      // Errores de conexi√≥n o productos no disponibles
      if (error.message && (
        error.message.includes('Could not find') ||
        error.message.includes('not found') ||
        error.message.includes('timeout')
      )) {
        console.log('‚ö†Ô∏è Producto no disponible o error de conexi√≥n');
        throw new Error('El producto no est√° disponible en este momento. Por favor, intenta m√°s tarde.');
      }
      
      throw error;
    }
  }

  static async restorePurchases(): Promise<any> {
    const mod = await ensurePurchasesLoaded();
    if (!mod) {
      // Simular restauraci√≥n cuando RevenueCat no est√° disponible
      console.log('üîÑ Simulando restauraci√≥n de compras');

      const hasSimulatedPurchase = await this.getSimulatedPurchaseStatus();

      if (hasSimulatedPurchase) {
        console.log('‚úÖ Compra simulada encontrada y restaurada');
        return {
          entitlements: {
            active: {
              pro: {
                isActive: true,
                willRenew: true,
                periodType: 'MONTHLY',
                expirationDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()
              }
            },
            all: {}
          },
          activeSubscriptions: ['gdc_pro_monthly'],
          nonSubscriptionTransactions: []
        };
      } else {
        console.log('‚ÑπÔ∏è No hay compras simuladas para restaurar');
        return {
          entitlements: {
            active: {},
            all: {}
          },
          activeSubscriptions: [],
          nonSubscriptionTransactions: []
        };
      }
    }

    try {
      return await mod.restorePurchases();
    } catch (error) {
      console.error('‚ùå Error restaurando compras:', error);
      throw error;
    }
  }
}